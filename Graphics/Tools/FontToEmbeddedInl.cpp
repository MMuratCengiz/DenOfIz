/*
Den Of Iz - Game/Game Engine
Copyright (c) 2020-2024 Muhammed Murat Cengiz

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/**
 * Tool to convert font files to compressed embedded C++ data
 * Usage: FontToEmbeddedInl <input.ttf> <output.inl> <array_name>
 */

#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <miniz/miniz.h>
#include <string>
#include <vector>
#include "DenOfIzGraphics/Assets/FileSystem/FileIO.h"
#include "DenOfIzGraphics/Assets/Import/FontImporter.h"
#include "DenOfIzGraphics/Assets/Serde/Font/FontAssetReader.h"

using namespace DenOfIz;

void WriteCompressedData( std::ofstream &out, const std::vector<uint8_t> &compressed, const std::string &arrayName )
{
    out << "// Auto-generated compressed font data\n";
    out << "// DO NOT EDIT - Generated by FontToEmbeddedInl tool\n\n";

    out << "const uint8_t " << arrayName << "Compressed[] = {\n\t";

    constexpr int bytesPerLine = 16;
    for ( size_t i = 0; i < compressed.size( ); ++i )
    {
        if ( i > 0 && i % bytesPerLine == 0 )
        {
            out << "\n\t";
        }
        out << "0x" << std::hex << std::setw( 2 ) << std::setfill( '0' ) << static_cast<int>( compressed[ i ] );
        if ( i < compressed.size( ) - 1 )
        {
            out << ", ";
        }
    }

    out << "\n};\n\n";
    out << "const size_t " << arrayName << "CompressedSize = " << std::dec << compressed.size( ) << ";\n";
}

int main( int argc, char *argv[] )
{
    if ( argc < 4 )
    {
        std::cerr << "Usage: " << argv[ 0 ] << " <input.ttf> <output.inl> <array_name>\n";
        std::cerr << "Example: " << argv[ 0 ] << " Inter.ttf InterCompressed.inl g_InterFont\n";
        return 1;
    }

    std::string inputPath  = argv[ 1 ];
    std::string outputPath = argv[ 2 ];
    std::string arrayName  = argv[ 3 ];

    std::filesystem::path outputFilePath( outputPath );
    std::filesystem::path outputDir = outputFilePath.parent_path( );
    if ( !outputDir.empty( ) && !std::filesystem::exists( outputDir ) )
    {
        std::filesystem::create_directories( outputDir );
    }

    try
    {
        std::filesystem::path importDir = outputDir.empty( ) ? std::filesystem::current_path( ) : outputDir;

        ImportJobDesc importJobDesc;
        importJobDesc.SourceFilePath  = InteropString( inputPath.c_str( ) );
        importJobDesc.TargetDirectory = InteropString( importDir.string( ).c_str( ) );

        FontImportDesc fontDesc{ };
        importJobDesc.Desc = &fontDesc;

        std::cout << "Importing font: " << inputPath << std::endl;

        FontImporter   importer( { } );
        ImporterResult result = importer.Import( importJobDesc );

        if ( result.ResultCode != ImporterResultCode::Success )
        {
            std::cerr << "Font import failed: " << result.ErrorMessage.Get( ) << std::endl;
            return 1;
        }

        std::string fontAssetPath;
        for ( size_t i = 0; i < result.CreatedAssets.NumElements( ); ++i )
        {
            AssetUri    uri  = result.CreatedAssets.GetElement( i );
            std::string path = uri.Path.Get( );
            if ( path.find( ".dzfont" ) != std::string::npos )
            {
                fontAssetPath = path;
                break;
            }
        }

        if ( fontAssetPath.empty( ) )
        {
            std::cerr << "No .dzfont file was created during import" << std::endl;
            return 1;
        }

        std::cout << "Font imported to: " << fontAssetPath << std::endl;

        std::filesystem::path normalizedPath( fontAssetPath );
        std::string           normalizedPathStr = normalizedPath.make_preferred( ).string( );
        std::cout << "Normalized path: " << normalizedPathStr << std::endl;

        InteropArray<Byte> fileData = FileIO::ReadFile( InteropString( normalizedPathStr.c_str( ) ) );
        if ( fileData.NumElements( ) == 0 )
        {
            std::cerr << "Failed to read font asset file: " << normalizedPathStr << std::endl;
            return 1;
        }

        size_t uncompressedSize = fileData.NumElements( );
        std::cout << "Uncompressed size: " << uncompressedSize << " bytes" << std::endl;

        mz_ulong             compressedBound = mz_compressBound( uncompressedSize );
        std::vector<uint8_t> compressedBuffer( compressedBound + sizeof( mz_ulong ) );

        memcpy( compressedBuffer.data( ), &uncompressedSize, sizeof( mz_ulong ) );
        mz_ulong compressedSize = compressedBound;
        int      compressResult = mz_compress2( compressedBuffer.data( ) + sizeof( mz_ulong ), &compressedSize, fileData.Data( ), uncompressedSize, MZ_BEST_COMPRESSION );

        if ( compressResult != MZ_OK )
        {
            std::cerr << "Compression failed with error: " << compressResult << std::endl;
            return 1;
        }

        compressedBuffer.resize( compressedSize + sizeof( mz_ulong ) );

        std::cout << "Compressed size: " << compressedBuffer.size( ) << " bytes" << std::endl;
        std::cout << "Compression ratio: " << std::fixed << std::setprecision( 2 ) << ( 100.0 * compressedBuffer.size( ) / uncompressedSize ) << "%" << std::endl;

        std::vector<uint8_t> testBuffer( uncompressedSize );
        mz_ulong             testSize         = uncompressedSize;
        int                  decompressResult = mz_uncompress( testBuffer.data( ), &testSize, compressedBuffer.data( ) + sizeof( mz_ulong ), compressedSize );

        if ( decompressResult != MZ_OK || testSize != uncompressedSize )
        {
            std::cerr << "Decompression test failed! Result: " << decompressResult << std::endl;
            return 1;
        }

        std::cout << "Decompression test passed!" << std::endl;
        std::ofstream outFile( outputPath );
        if ( !outFile.is_open( ) )
        {
            std::cerr << "Failed to open output file: " << outputPath << std::endl;
            return 1;
        }

        WriteCompressedData( outFile, compressedBuffer, arrayName );
        outFile.close( );

        std::cout << "Successfully generated: " << outputPath << std::endl;
        std::filesystem::remove(fontAssetPath);
        return 0;
    }
    catch ( const std::exception &e )
    {
        std::cerr << "Error: " << e.what( ) << std::endl;
        return 1;
    }
}
